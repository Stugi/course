Если имеются изменённые файлы, которые ещё не были переведены в подготовленное состояние, то для возврата их в исходное состояние можно использовать команду:

```
$ git clean -f <файлы>
```
Если файлы были переведены в подготовленное состояние, то в исходное состояние их можно перевести, используя команду:

```
$ git checkout -f <файлы>
```
Если нужно изменения оставить, но перевести файлы из подготовленного состояния в неподготовленное, используйте такую команду:

```
$ git reset HEAD
```
Git reset весьма полезная команда, так как позволяет выполнение в трёх режимах. По умолчанию используется режим, в котором при откате к указанному коммиту сохраняется история, но все изменения, сделанные после этого коммита, переводятся в неподготовленное состояние.

Явно этот режим можно вызвать, используя флаг --mixed:

```
$ git reset --mixed <commit_hash | указатель_на_коммит>
```
Второй режим позволяет выполнить откат до коммита, при этом вся история сохраняется и переводится в подготовленное состояние. За этот режим отвечает флаг --soft:

```
$ git reset --soft <commit_hash | указатель_на_коммит>
```
И наконец, если нужно проигнорировать все изменения после заданного коммита, откатиться к нему можно так:

```
git reset --hard <commit_hash | указатель_на_коммит>
```

Git flow — это простой подход к организации рабочего процесса над кодом с использованием Git в команде на основе веток, созданный для проектов, регулярно развертываемых на рабочих серверах.

Для разработчика, работающего с кодом в Git, последний является частью повседневной работы. Он разрабатывает новые функции, объединяет их позже, затем выпускает приложение в виде релизов и, наконец, исправляет ошибки. Если нет чёткого способа делать все это, особенно в команде, очень быстро возникают проблемы. Вот почему git-flow и был создан: он предоставляет вам чёткий рабочий «поток» для повседневной работы с Git.

В этом подходе есть две основные ветки:

master,
develop.
Ветка master предназначена для рабочего кода, который будет располагаться на производственном сервере. В этой ветке код отлаженный и рабочий. Здесь код не меняется до тех пор, пока старший программист не решает, что текущая работа достигла момента, когда нужно выпустить новую версию или релиз программы.

Ветка develop — для кода, который в настоящее время находится в разработке. Здесь объединены код, который был написан для наращивания нового функционала, и код исправления ошибок, поэтому здесь событий гораздо больше.

Помимо этого, есть так называемые сопутствующие ветки:

features,
releases,
hotfixes.
У каждой из этих ветвей есть чёткие правила, откуда они берутся и куда сливаются. Каждая из них — это просто набор веток, или лучше сказать подветок. Ветки features, releases, hotfixes — логические, они описываются в модели git-flow, чтобы представить дерево зависимостей веток. Фактически же вместо них выступают подветки (например, каждый новый функционал будет создаваться в подветках, в наименование которых принято включать слово feature).

Рассмотрим по порядку сопутствующие ветки в этой модели. Начнём с features.

img
Рис 25.7.1. Пример части истории репозитория, работа над которым ведётся по модели git-flow с указанием двух веток feature
Источник: www.codewall.co
На рисунке 25.7.1. видно, фактически ветки features нет, но есть две тематические ветки, которые вместе и представляют из себя код логической ветки features. Если вы хотите запрограммировать новую функцию или провести рефакторинг, ветка feature — непосредственное место работы с таким кодом. Вы создаёте новую функциональную ветку, часто её называют тематической, и делаете своё дело, не трогая общий процесс разработки.

В какой-то момент функционал готов, работа над ним завершается, и произведённые изменения снова объединяются с веткой develop. Это ветка, которая, вероятно, используется чаще всего в модели git-flow, именно здесь происходят все действия. Весь код, который всё ещё находится в разработке, находится где-то в ветке feature.

Это также идеальное место, если вы хотите поэкспериментировать. Если не работает, просто удалите ветку, и ничего не произойдёт. Никто не должен знать, да и не узнает. Именно в ней программисты чаще всего используют рассмотренную выше процедуру перебазирования.

Когда создаётся какая-нибудь функциональная ветка, она создаётся из ветки develop и снова сливается с ней. Имя ветки принято именовать так: features /<описание_функционала>.

Если вы решаете, что у вас достаточно хорошо протестированы функции, чтобы внедрить их в производство, вы делаете релизную ветку. Здесь не должно быть никакой разработки, только мелкие исправления ошибок в последнюю минуту, ошибки версии и так далее. И больше ничего.

Теперь ветки релиза. Когда создаётся ветка релиза, она создаётся из ветки develop и снова сливается с ветками master и develop. Смысл создания этой ветки заключается в том, что вы можете получать и просматривать рабочий код из ветки master, в то время как ветка develop уже может получать новые функции для готовящегося следующего выпуска. Когда создаётся ветка релиза, ей присваивается номер версии. Не раньше! Всё, что было до этого момента в ветке develop, предназначено для «следующего выпуска». Название веток здесь принято давать так: release /<релиз>.

img
Рис 25.7.2. Пример части истории репозитория, работа над которым ведётся по модели git-flow с показанной веткой релиза
Источник: www.codewall.co
И наконец, поговорим о ветках hotfixes.

img
Рис 25.7.3. Пример части истории репозитория, работа над которым ведётся по модели git-flow с показанной веткой hotfix
Источник: www.codewall.co
Рассмотрим ситуацию, когда вы запустили свой отлаженный (как вы подумали) код в производство, но тут же заметили ошибку, которую нужно исправить в производственной среде. Нет повода для паники, такое случается со всеми. И для этого есть решение git-flow: ветка срочных исправлений, она же hotfixes. Она берёт код из продакшена, то есть создаются такие ветки прямо от ветки master, ошибка исправляется, и изменения объединяются обратно в master и сливается с develop.

Смысл такого создания веток с исправлениями: потенциально нестабильный код в ветке develop не повлияет на наше исправление, плюс другие разработчики могут продолжить кодирование, в то время как программист, допустивший ошибку, может её спокойно править.

Ветки исправлений получают номер версии при создании на основе текущего релиза (например, 1.2.1, если ва